# 设计模式
    设计模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）
## 程序开发原则
1. 开闭原则
2. 里氏替换原则
3. 依赖倒置原则
4. 单一职责原则
5. 接口隔离原则
6. 迪米特法原则
7. 合成复用原则
### 1.开闭原则
    开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。
#### 1.1.开闭原则作用
* `对测试影响`  
遵循开闭原则的代码，测试只需要对扩展代码进行测试就可以了  
* `可以提高代码的复用性`  
粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性  
* `可以提高软件的可维护性`  
遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护  
#### 1.2.开闭原则实现方法
**`抽象约束、封装变化`**  
通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。
### 2.里氏替换原则
    里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
#### 2.1.里氏替换原则的作用
* 里氏替换原则是实现开闭原则的重要方式之一
* 克服了继承中重写父类造成的可复用性变差的缺点
* 是动作正确性的保证，即类的扩展不会给已有的系统引入新的错误，降低代码出错的可能性
* 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险
#### 2.2.里氏替换原则的实现方法
* 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
* 子类中可以增加自己特有的方法
* 当子类的方法重载父类的方法时，方法的前置条件（方法输入的参数）要比父类更宽松
* 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等
* 如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。
## **创建型模式**
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
#### 创建型模式包含
    1）工厂方法模式
    2）抽象工厂方法模式
    3）单例模式
    4）建造者模式
    5）原型模式
### **`1.工厂方法模式（Factory Method Pattern）`**
    在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。
    工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建
#### 工厂方法主要包括三种
    1.1.普通工厂方法模式
        就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。
        步骤：
            1）首先创建共同接口
            2）创建各自的实现类
            3）创建工厂类

    1.2.多个工厂方法模式
        多个工厂方法模式是提供多个工厂方法，分别创建对象。

    1.3.静态工厂方法模式
        多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。
#### 工厂方法优缺点
    优点：
        1）一个调用者想创建一个对象，只要知道其名称就可以了。
        2）扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。
        3）屏蔽产品的具体实现，调用者只关心产品的接口。
    缺点：
        1）增加产品，需要增加新的工厂类，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。

### **`2.抽象工厂方法模式（Abstract Factory Pattern）`**
    工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。
#### 适用情况
    1）一个系统要独立与它产品的创建、组合和表示时
    2）一个系统要由多个产品系列中的一个来配置时
    3）要强调一系列相关的产品对象的设计以便进行联合使用时
    4）提供一个产品类库，而只想显示它们的接口而不是实现时
#### 参与角色
* AbstractFactory(抽象工厂)：用于声明生成抽象产品的操作接口;
* ConcreteFactory(具体工厂)：实现创建具体产品对象的操作；
* AbstractProduct(抽象产品)：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；
* Product(具体产品)：定义具体工厂生产的具体产品对象，实现AbstractProduct接口；
* Client(客户):仅使用由AbstractFactory和AbstractProduct类声明的接口。
#### 抽象工厂方法优缺点
    优点：
        1）分离了具体的类
        2）它使得易于交换产品系列
        3）它有利于产品的一致性
    缺点：
        1）难以支持新种类的产品
### **`3.单例模式（Singleton Pattern）`**
#### 单例模式定义
    保证一个类仅有一个实例，并提供一个访问它的全局访问点。
    单例模式一般体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
#### 单例模式优点
1. 在内存里只有一个实例，减少内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）
2. 避免对资源的多重占用（比如写文件操作）
#### 单例模式分类
* 饿汉式
* 懒汉式
* 双重校验锁
* 枚举式
#### 饿汉式
